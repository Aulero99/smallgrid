/*!
  * Bootstrap v1.6.4 (undefined)
  * Copyright 2011-2024 Auston Robertson <auston.robertson.business@gmail.com>
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const vars = { spacer: 0, minmax: null, prefix: null, xxs: 0, xs: 0, sm: 0, md: 0, lg: 0, xl: 0, xxl: 0, dev: !1, 'modal-transition-time': null }; function log(e, t) {
  if (vars.dev) {
    console[e](`[${e}] :: ${(new Date()).toLocaleTimeString()} :: `, ...t)
  } else {
    switch (e) {
      case 'log': case 'assert': { return
      }
    }

    console[e](`[${e}] :: ${(new Date()).toLocaleTimeString()} :: `, ...t)
  }
}

const logger = { log() {
  log('log', arguments)
}, error() {
  log('error', arguments)
}, warn() {
  log('warn', arguments)
}, assert() {
  log('assert', arguments)
}, trace() {
  log('trace', arguments)
} }; const under$1 = new Event('under'); const xxs = new Event('xxs'); const xs = new Event('xs'); const sm$1 = new Event('sm'); const md$1 = new Event('md'); const lg$1 = new Event('lg'); const xl$1 = new Event('xl'); const xxl$1 = new Event('xxl'); const over$1 = new Event('over'); const portrait$1 = new Event('portrait'); const landscape$1 = new Event('landscape'); let orientation = null; let screen = null; let loaded = !1; function callScreen(e, t) {
  screen !== t && (screen = t, loaded && window.dispatchEvent(e))
}

function callOrient(e, t) {
  orientation !== t && (orientation = t, loaded && window.dispatchEvent(e))
}

function loadingCheck() {
  loaded || (loaded = !0, screen = null, orientation = null, document.removeEventListener('DOMContentLoaded', setter.loadFlip), setter.update())
}

class Setter {
  setup() {
    logger.log('Event Setter Logic Online'), document.addEventListener('DOMContentLoaded', setter.loadFlip), window.addEventListener('resize', this.update), window.matchMedia('(orientation: portrait)').addEventListener('change', (() => {
      this.update()
    })), this.update()
  }

  loadFlip() {
    loadingCheck()
  }

  update() {
    const e = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; if (e > (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) ? callOrient(landscape$1, 'landscape') : callOrient(portrait$1, 'portrait'), vars.minmax === 'max-width') {
      switch (e) {
        case e < vars.xxs: { callScreen(xxs, 'xxs'); break
        }

        case e > vars.xxs && e <= vars.xs: { callScreen(xs, 'xs'); break
        }

        case e > vars.xs && e <= vars.sm: { callScreen(sm$1, 'sm'); break
        }

        case e > vars.sm && e <= vars.md: { callScreen(md$1, 'md'); break
        }

        case e > vars.md && e <= vars.lg: { callScreen(lg$1, 'lg'); break
        }

        case e > vars.lg && e <= vars.xl: { callScreen(xl$1, 'xl'); break
        }

        case e > vars.xl && e <= vars.xxl: { callScreen(xxl$1, 'xxl'); break
        }

        default: { callScreen(over$1, 'over')
        }
      }
    } else {
      switch (e) {
        case e < vars.xxs: { callScreen(under$1, 'under'); break
        }

        case e > vars.xxs && e <= vars.xs: { callScreen(xxs, 'xxs'); break
        }

        case e > vars.xs && e <= vars.sm: { callScreen(xs, 'xs'); break
        }

        case e > vars.sm && e <= vars.md: { callScreen(sm$1, 'sm'); break
        }

        case e > vars.md && e <= vars.lg: { callScreen(md$1, 'md'); break
        }

        case e > vars.lg && e <= vars.xl: { callScreen(lg$1, 'lg'); break
        }

        case e > vars.xl && e <= vars.xxl: { callScreen(xl$1, 'xl'); break
        }

        default: { callScreen(xxl$1, 'xxl')
        }
      }
    }
  }

  clearAllThenUpdate() {
    this.clearOrientThenUpdate(), this.clearScreenThenUpdate()
  }

  clearScreenThenUpdate() {
    screen = null, orientation = null, this.update()
  }

  clearOrientThenUpdate() {
    screen = null, orientation = null, this.update()
  }

  returnOrientation() {
    return orientation || this.update(), logger.log('The current orientation is ', orientation), orientation
  }

  returnScreen() {
    return screen || this.update(), logger.log('The current screen is ', screen), screen
  }
} const setter = new Setter(); let dynamicWidth = null; let dynamicHeight = null; class VolSizer {
  setup() {
    logger.log('Sizer Logic Online'), window.addEventListener('resize', this.update), window.matchMedia('(orientation: portrait)').addEventListener('change', (() => {
      this.update()
    }))
  }

  update() {
    const e = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; const t = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; if (t < dynamicHeight && e === dynamicWidth && e <= vars.lg) {
      return
    }

    dynamicWidth = e, dynamicHeight = t; const o = document.querySelector(':root'); const { prefix: r } = vars; o.style.setProperty(`--${r}vh100`, `${t}px`), o.style.setProperty(`--${r}vw100`, `${e}px`)
  }
} const volSizer = new VolSizer(); const
  root = document.querySelector(':root'); function getStyle(e) {
  const t = root == null ? null : getComputedStyle(root); return t === null ? null : t.getPropertyValue(e)
}

function returnNumbersOnly(e) {
  let t = ''; for (const o of e) {
    if (Number.isNaN(o) && o !== '.') {
      break
    }

    t += o
  }

  return Number(t)
}

function getCssRoot() {
  return Array.from(document.styleSheets).filter((e => e.href === null || e.href.startsWith(window.location.origin))).reduce(((e, t) => [...e, ...Array.from(t.cssRules).reduce(((e, t) => t.selectorText === ':root' ? [...e, ...Array.from(t.style).filter((e => e.startsWith('--')))] : e), [])]), [])
}

class Options {
  importVariablesFromCss() {
    const e = getCssRoot(); logger.log('the found root is: ', e); const t = getStyle('--prefix'); vars.prefix = t; for (const o of e) {
      const e = o.slice(2); const r = getStyle(o); let n = null; r.length === 0 || e.length > 30 || e !== 'prefix' && e !== `${t}vh100` && e !== `${t}vw100` && e !== `${t}spacer` && e.includes(t) && (n = Number.isNaN(r[0]) ? r : returnNumbersOnly(r), vars[`${e.slice(t.length)}`] = n)
    }

    const o = returnNumbersOnly(getStyle(`--${t}spacer`)) * returnNumbersOnly(window.getComputedStyle(document.body).fontSize); vars.spacer = o, logger.log('The vars are now: ', vars), document.removeEventListener('DOMContentLoaded', options.importVariablesFromCss)
  }

  dev() {
    vars.dev = !0, logger.log('set dev mode to true')
  }
} const options = new Options(); document.addEventListener('DOMContentLoaded', options.importVariablesFromCss); class Suspendors {
  constructor() {
    logger.log('Suspendors Online'), volSizer.setup(), setter.setup()
  }

  triggerAll() {
    setter.clearAllThenUpdate()
  }

  triggerOrientation() {
    setter.clearOrientThenUpdate()
  }

  triggerScreen() {
    setter.clearScreenThenUpdate()
  }

  returnScreen() {
    return setter.returnScreen()
  }

  returnOrientation() {
    return setter.returnOrientation()
  }

  returnVariables() {
    return vars
  }

  dev() {
    options.dev()
  }
} const suspendors = new Suspendors(); const under = []; const sm = []; const md = []; const lg = []; const xl = []; const xxl = []; const over = []; const landscape = []; const
  portrait = []; class Registrar {
  constructor() {
    logger.log('Registrar Online'), window.addEventListener('under', (() => {
      this.trigger('under')
    }), !1), window.addEventListener('xxs', (() => {
      this.trigger('xxs')
    }), !1), window.addEventListener('xs', (() => {
      this.trigger('xs')
    }), !1), window.addEventListener('sm', (() => {
      this.trigger('sm')
    }), !1), window.addEventListener('md', (() => {
      this.trigger('md')
    }), !1), window.addEventListener('lg', (() => {
      this.trigger('lg')
    }), !1), window.addEventListener('xl', (() => {
      this.trigger('xl')
    }), !1), window.addEventListener('xxl', (() => {
      this.trigger('xxl')
    }), !1), window.addEventListener('over', (() => {
      this.trigger('over')
    }), !1), window.addEventListener('portrait', (() => {
      this.trigger('portrait')
    }), !1), window.addEventListener('landscape', (() => {
      this.trigger('landscape')
    }), !1)
  }

  trigger(e) {
    logger.log(`Triggering ${e}`), e === 'under' ? this.runEvents(under) : (e === 'sm' ? this.runEvents(sm) : e === 'md' ? this.runEvents(md) : e === 'lg' ? this.runEvents(lg) : e === 'xl' ? this.runEvents(xl) : e === 'xxl' ? this.runEvents(xxl) : e === 'over' ? this.runEvents(over) : e === 'landscape' ? this.runEvents(landscape) : e === 'portrait' && this.runEvents(portrait))
  }

  runEvents(e) {
    if (!(e.length < 1)) {
      for (const t of e) {
        typeof t === 'function' && t()
      }
    }
  }

  setEventFlags(e, t) {
    if (typeof e === 'function') {
      if (logger.log('valid function'), t === 'under') {
        return void under.push(e)
      }

      if (t === 'xxs') {
        return
      }

      if (t === 'xs') {
        return
      }

      if (t === 'sm') {
        return void sm.push(e)
      }

      if (t === 'md') {
        return void md.push(e)
      }

      if (t === 'lg') {
        return void lg.push(e)
      }

      if (t === 'xl') {
        return void xl.push(e)
      }

      if (t === 'xxl') {
        return void xxl.push(e)
      }

      if (t === 'over') {
        return void over.push(e)
      }

      if (t === 'landscape') {
        return void landscape.push(e)
      }

      t === 'portrait' && portrait.push(e)
    } else {
      logger.log('not a valid function')
    }
  }

  under(e) {
    logger.log('registering function: ', e, ' at breakpoint under'), this.setEventFlags(e, 'under')
  }

  xxs(e) {
    logger.log('registering function: ', e, ' at breakpoint sm'), this.setEventFlags(e, 'xxs')
  }

  xs(e) {
    logger.log('registering function: ', e, ' at breakpoint sm'), this.setEventFlags(e, 'xs')
  }

  sm(e) {
    logger.log('registering function: ', e, ' at breakpoint sm'), this.setEventFlags(e, 'sm')
  }

  md(e) {
    logger.log('registering function: ', e, ' at breakpoint md'), this.setEventFlags(e, 'md')
  }

  lg(e) {
    logger.log('registering function: ', e, ' at breakpoint lg'), this.setEventFlags(e, 'lg')
  }

  xl(e) {
    logger.log('registering function: ', e, ' at breakpoint xl'), this.setEventFlags(e, 'xl')
  }

  xxl(e) {
    logger.log('registering function: ', e, ' at breakpoint xxl'), this.setEventFlags(e, 'xxl')
  }

  over(e) {
    logger.log('registering function: ', e, ' at breakpoint over'), this.setEventFlags(e, 'over')
  }

  landscape(e) {
    logger.log('registering function: ', e, ' at orientation landscape'), this.setEventFlags(e, 'landscape')
  }

  portrait(e) {
    logger.log('registering function: ', e, ' at orientation portrait'), this.setEventFlags(e, 'portrait')
  }
} const registrar = new Registrar(); class Modal {
  constructor(e) {
    this.static = e.static || !1, this.scrollable = e.scrollable || !1, this.disableBodyScroll = e.disableBodyScroll || !0, this.centered = e.centered || !1, this.animation = e.animation || !0, this.transitionTime = e.transitionTime || vars['modal-transition-time'] ? vars['modal-transition-time'] : 1
  }
} let targetModalId = null; let targetModal = null; let params = {}; let modalClosing = !1; let modalOpening = !1; function setFocus() {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target setFocus()')
  }

  let e = 0; Array.prototype.forEach.call(targetModal.querySelectorAll('[autofocus]'), (() => {
    e++
  })), e === 0 && (logger.log('no autofocus target provided, setting first child to autofocus.'), targetModal.firstChild.setAttribute('autofocus', ''))
}

function awaitEscKeyCloseModal(e) {
  e.key !== 'Escape' && e.keyCode !== 27 || (logger.log('escape pressed'), closeModal())
}

function awaitOutClickCloseModal(e) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target awaitOutClickCloseModal(e)')
  }

  if (!targetModal.checkVisibility()) {
    return
  }

  const t = targetModal.getBoundingClientRect(); (e.x < t.left || e.x > t.width + t.left || e.y < t.top || e.y > t.height + t.top) && closeModal()
}

function awaitOutTouchStartToCloseModal(e) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target awaitOutTouchStartToCloseModal(e)')
  }

  const t = e.changedTouches[0].clientX; const o = e.changedTouches[0].clientY; const r = targetModal.getBoundingClientRect(); (t < r.left + window.scrollX || t > r.left + window.scrollX + r.width || o < r.top + window.scrollY || o > r.top + window.scrollY + r.height) && targetModal.addEventListener('touchend', awaitOutTouchEndToCloseModal)
}

function awaitOutTouchEndToCloseModal(e) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target awaitOutTouchEndToCloseModal(e)')
  }

  const t = e.changedTouches[0].clientX; const o = e.changedTouches[0].clientY; const r = targetModal.getBoundingClientRect(); targetModal.removeEventListener('touchend', awaitOutTouchEndToCloseModal), (t < r.left + window.scrollX || t > r.left + window.scrollX + r.width || o < r.top + window.scrollY || o > r.top + window.scrollY + r.height) && closeModal()
}

function getScrollBarWidth() {
  const e = document.createElement('div'); e.style.cssText = 'overflow:scroll; visibility:hidden; position:absolute;', document.body.append(e); const t = e.offsetWidth - e.clientWidth; return e.remove(), t
}

function toggleScroll(e = !0) {
  if (e) {
    const e = getScrollBarWidth(); document.body.classList.add('modal-open'), document.body.style.paddingRight = `${e}px`
  } else {
    document.body.classList.remove('modal-open'), document.body.style = ''
  }
}

function toggleEventListenersToCloseModal(e = !0) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target toggleEventListenersToCloseModal(toggle = true)')
  }

  e ?
    (targetModal.addEventListener('cancel', (e => {
      e.preventDefault()
    })), window.addEventListener('click', awaitOutClickCloseModal), document.addEventListener('keydown', awaitEscKeyCloseModal), window.addEventListener('touchstart', awaitOutTouchStartToCloseModal)) :
    (targetModal.removeEventListener('cancel', (e => {
      e.preventDefault()
    })), window.removeEventListener('click', awaitOutClickCloseModal), document.removeEventListener('keydown', awaitEscKeyCloseModal), window.removeEventListener('touchstart', awaitOutTouchStartToCloseModal))
}

function toggleOptionsAndAttributes(e = !0, t) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target toggleOptionsAndAttributes(toggle = true, options)')
  }

  t || (t = new Modal(params)), e ? (t.centered && targetModal.setAttribute('data-centered', ''), t.static && targetModal.setAttribute('data-static', ''), t.scrollable && targetModal.setAttribute('data-scrollable', ''), t.animation || targetModal.setAttribute('data-no-animation', '')) : (t.centered && targetModal.removeAttribute('data-centered', ''), t.static && targetModal.removeAttribute('data-static', ''), t.scrollable && targetModal.removeAttribute('data-scrollable', ''), t.animation || targetModal.removeAttribute('data-no-animation', ''))
}

function setModalValuesAndEnvironment(e, t) {
  params = new Modal(t), targetModalId = e, targetModal = document?.getElementById(targetModalId)
}

function resetModalValuesAndEnvironment() {
  targetModalId = null, targetModal = null
}

async function openModal(e, t) {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target openModal(id, options)')
  }

  toggleOptionsAndAttributes(!0), setFocus(), targetModal.style.display = 'block', targetModal.addEventListener('transitionend', toggleOnEventListenersToCloseModal), setTimeout((() => {
    targetModal.setAttribute('data-modal-open', '')
  }), 1); const o = await modalTransitionTimer(t); logger.log('Modal Open:', o), targetModal.showModal()
}

function toggleOnEventListenersToCloseModal() {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target toggleOnEventListenersToCloseModal()')
  }

  targetModal.removeEventListener('transitionend', toggleOnEventListenersToCloseModal), toggleEventListenersToCloseModal(!0)
}

async function closeModal() {
  if (!targetModalId || !targetModal) {
    throw new Error('no modal target closeModal()')
  }

  toggleEventListenersToCloseModal(!1), targetModal.addEventListener('transitionend', toggleOffEventListenersToCloseModal), targetModal.removeAttribute('data-modal-open'); const e = await modalTransitionTimer(params); logger.log('Modal Closed:', e)
}

function toggleOffEventListenersToCloseModal() {
  targetModal.removeEventListener('transitionend', toggleOffEventListenersToCloseModal), targetModal.style = '', toggleEventListenersToCloseModal(!1), toggleOptionsAndAttributes(!1), targetModal.close()
}

async function modalTransitionTimer(e) {
  const t = e ? e.transitionTime + 50 : params.transitionTime + 50; return new Promise((e => {
    setTimeout((() => {
      e(!0)
    }), t)
  }))
}

class Modals {
  async open(e = '', t = {}) {
    try {
      if (e === '') {
        throw new Error('No id provided')
      }

      if (modalOpening) {
        return
      }

      modalOpening = !0, targetModalId !== null && await this.close(targetModalId), setModalValuesAndEnvironment(e, t), toggleScroll(!0), await openModal(e, t), modalOpening = !1
    } catch (error) {
      logger.log(error)
    }
  }

  async close() {
    try {
      if (targetModalId === null) {
        throw new Error('no modal to close')
      }

      if (modalClosing) {
        return
      }

      modalClosing = !0, await closeModal(), modalOpening || toggleScroll(!1), resetModalValuesAndEnvironment(), modalClosing = !1
    } catch (error) {
      logger.error(error)
    }
  }

  async toggle(e = '', t = {}) {
    e === '' ? await this.close() : await (targetModalId === null || targetModalId !== e ? this.open(e, t) : this.close())
  }
} const modal = new Modals(); class Forms {
  test() {
    logger.log('Dev Mode confirmed - forms')
  }
} const forms = new Forms(); class Pop {
  test() {
    logger.log('Dev Mode confirmed - pop')
  }
} const pop = new Pop(); class Loaders {
  loadAllImg() {
    Array.prototype.forEach.call(document.querySelectorAll('img[data-src]'), (e => {
      e.setAttribute('src', e.getAttribute('data-src')), e.addEventListener('load', (() => {
        e.removeAttribute('data-src')
      }))
    }))
  }

  loadAllImgInId(e) {
    Array.prototype.forEach.call(document.getElementById(e).querySelectorAll('img[data-src]'), (e => {
      e.setAttribute('src', e.getAttribute('data-src')), e.addEventListener('load', (() => {
        e.removeAttribute('data-src')
      }))
    }))
  }
} const loaders = new Loaders(); export { forms, loaders, modal, options, pop, registrar, suspendors }
// # sourceMappingURL=suspendors.esm.min.js.map
